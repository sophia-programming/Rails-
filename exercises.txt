Ruby on Rails（Rails）特徴
1. MVCアーキテクチャ:
Railsはモデル（Model）、ビュー（View）、コントローラー（Controller）の三層に分かれたMVCアーキテクチャを採用。
これにより、コードの整理が容易になり、開発と保守がしやすくなります。

2. テストがしやすい:
Railsにはテストフレームワーク（RSpecやMinitestなど）が組み込まれており、単体テスト、機能テスト、統合テストを簡単に作成できます。
テスト駆動開発（TDD）のサポートも充実しています。

3. Rails Console:
Railsにはインタラクティブなコマンドラインツールであるrails consoleがあり、アプリケーションのモデルやデータベースに直接アクセスして操作することができます。
これにより、デバッグやデータ操作が容易になります。

4. Active Record:
RailsのORM（オブジェクト関係マッピング）ツールであるActive Recordは、データベースのテーブルとRubyのクラスを対応付け、データベース操作を簡素化します。
SQLを書かずにデータ操作が可能です。

5. Convention over Configuration（設定より規約）:
Railsは「設定より規約」の原則に基づいて設計されており、一般的な設定はデフォルトで提供されます。
これにより、開発者は設定に時間を費やすことなく、迅速に開発を進めることができます。

6. 自動化とジェネレータ:
Railsにはスキャフォルディングやジェネレータがあり、モデル、コントローラー、ビュー、マイグレーションファイルなどを自動生成できます。
これにより、開発の初期段階が大幅に効率化されます。

7. 豊富なライブラリとプラグイン:
Railsには多くのGem（ライブラリ）が存在し、機能を簡単に追加できます。
これにより、認証、承認、ファイルアップロード、検索機能など、多くの機能を迅速に実装できます。

8. セキュリティ:
Railsはセキュリティに関しても多くの機能を提供しており、SQLインジェクションやクロスサイトスクリプティング（XSS）などの脆弱性に対する対策が標準で組み込まれています。




Rubyにシンボルがある理由
シンボルと文字列、どちらをコードで使用しても変わらないが、メモリ効率などを考えるとシンボルを使用した方がいい　✅

シンボルとは？
シンボルは、Rubyプログラミング言語で頻繁に使用されるデータ型です。
シンボルは一見文字列のように見えますが、実際には文字列とは異なり、メモリ効率が高く、高速な操作が可能です。

### 文字列とシンボルの違い
簡単に説明すると、文字列はデータを表すために使用され、シンボルはコードの一部として使用されます。
文字列とシンボルは相互に変換可能であり、以下のような違いがあります。
- **文字列**: データ（定数や変数の値など）を表すために使われる。
- **シンボル**: コードの一部として使用され、メソッド呼び出しの引数などに使われる。

### まとめ
- **文字列**: メモリを毎回アロケーションし、バイトごとに比較。GC（ガベージコレクション）で回収可能。
- **シンボル**: 一度だけアロケーションされ、整数で比較。高速で重複しない。


マスアサインメントとは？
マスアサインメントを利用すると、ハッシュ（キーと値のペアの集まり）を使用して複数の属性を一度に設定することができます。
これにより、個々の属性を一つ一つ設定する必要がなくなり、コードの簡潔さと読みやすさが向上します。


partial（パーシャル）とは？
パーシャル（部分テンプレート）は、ビューの一部を再利用可能なコンポーネントとして分離するための機能
これにより、同じコードを複数の場所で再利用でき、ビューのメンテナンスが容易になる。
パーシャルは以下の2つの条件を満たすことで定義されます：
1. **アンダースコアで始まるファイル名**:
    - パーシャルファイルは通常、ファイル名がアンダースコアから始まります。例: `_header.html.erb`。
2. **`render`メソッドを使用して呼び出す**:
    - パーシャルは、他のビューから`render`メソッドを使用して読み込みます。例: `<%= render 'shared/header' %>`。


Railsの開発フロー
通常MVCモデルに沿って行われます。
1. **ルーティング**:
    - リクエストを受け取った際に、どのコントローラのどのアクションを呼び出すかを決定する。
2. **コントローラ**:
    - リクエストを受け取り、モデルを操作してビューにデータを渡す。
3. **モデル**:
    - データベースとやり取りするためのクエリを実行し、データを操作する。
4. **ビュー**:
    - ユーザーに表示するためのHTMLを生成する。


Gravatar
無料のサービスで、プロフィール写真をアップロードして、指定したメールアドレスと関連付けることができる
gravatar_forヘルパーメソッドを使ってGravatarの画像を利用できる

ユーザー登録ページ
上記で重要な要素は、ユーザー登録に不可欠な情報を入力するフォーム。
Railsではform_withヘルパーメソッド
無効なフォームの送信を扱う ⇨ フォームが有効な場合のみ新規ユーザーをデータベースに保存できるようにする ⇨ ユーザー登録フォーム完成

Bootstrap CSSは、flashのクラス用に4つのスタイルを持っています（success、info、warning、danger）


セッション
ユーザーログインの必要なWebアプリケーションでは、セッション（Session）と呼ばれる半永続的な接続をコンピュータ間（ユーザーのパソコンのWebブラウザとRailsサーバーなど）に別途設定します。
Railsでセッションを実装する方法として最も一般的なのは、cookiesを使う方法
cookiesとは、ユーザーのブラウザに保存される小さなテキストデータのこと
ログインでセッションを作成する場合に最初に行うのは、入力が無効な場合の処理

flashのメッセージとは異なり、flash.nowのメッセージはその後リクエストが発生したときに消滅

Webアプリケーションの文脈では、
1. 認証（authentication）はサイトのユーザーを識別することであり、
2. 認可（authorization）はそのユーザーが実行可能な操作を管理すること

HTTPステータスコード:see_other
POST、PUT、DELETEなどの非GETメソッドでリソースを操作した後に、クライアントにリダイレクトを指示する場合に特に有用です。
主な用途は、フォーム送信後のリダイレクトやPOST-Redirect-GETパターンの実現。これにより、ブラウザの再送信を防ぎ、ユーザーエクスペリエンスを向上させます。
サーバーは「303 See Other」ステータスコードとともに、リダイレクト先のURLをブラウザに返します。ブラウザはこのURLにGETリクエストを送信し、リダイレクト先のページを表示します。
＝＝＝　例）ユーザーがコメントフォームを送信する。　＝＝＝
ユーザーがコメントフォームを送信（POSTリクエスト）。
サーバーがコメントを保存し、ユーザーをコメント一覧ページにリダイレクト（303 See Other）。
ユーザーがページをリロードしても、最後に送信されたのがGETリクエストなので、コメントが再度送信されることはありません。

log in ヘルパー
一般的にユーザーがアプリケーションに通常の方法でログインする際に使用されます。
このヘルパーは、ユーザーの認証情報を検証し、成功した場合にそのユーザーをログイン状態にします。
log in as ヘルパー
主に管理者が他のユーザーとしてログインするために使用されます。
これは通常、管理者がサポート目的でユーザーのアカウントにアクセスする際に使用されます。このヘルパーは、管理者が特定のユーザーとしてログインし、そのユーザーの視点からアプリケーションを使用することを可能にします。

名前付きルーティングは、Railsアプリケーションにおいてルートに名前を付けて、それをコード内で簡単に参照できるようにするもの。
rails routes コマンドを使って確認し、リンクやリダイレクト先のURLを名前付きルーティングを使って指定することができます。

remember_digestは、ユーザーの永続的セッションを実現するために使用されるトークンのハッシュ化された値。
永続的セッションを実現するために、アプリケーションはユーザーがログインした状態を保持し、再度ログインすることなくアクセスできるようにするためにこのトークンを使用。
======== 永続的セッションの流れ ========
1. ユーザーがログインする:
ユーザーがログインすると、サーバー側でランダムなトークンを生成します。このトークンはremember_tokenとしてユーザーに割り当てられます。

2. トークンをハッシュ化して保存:
セキュリティのために、このトークンをそのまま保存するのではなく、ハッシュ化して保存します。ハッシュ化されたトークンがremember_digestです。これにより、データベースが漏洩した場合でも、元のトークンが直接的に露出しないようにします。

3. クッキーにトークンを保存:
元のトークン（ハッシュ化されていないトークン）をクッキーに保存し、ユーザーのブラウザに送信します。これにより、次回ユーザーがサイトにアクセスした際に、このトークンを使用してユーザーを認証することができます。

4. ユーザーがサイトにアクセスする:
ユーザーが再度サイトにアクセスすると、ブラウザはクッキーに保存されているトークンをサーバーに送信します。

5. トークンの検証:
サーバーは受け取ったトークンをハッシュ化し、データベースに保存されたremember_digestと比較。これにより、ユーザーが正当なログイン状態にあることを確認します。
====================================

account_activationメソッドは、アカウントの有効化を管理するために使用されるメソッド
